#include "chip.h"
#include "state.h"
#include "config.h"
#include "emcsm.h"

#include <sysreg.h>
#include <model.h>

#include <stdint.h>
#include <stddef.h>

typedef struct
{
    uint8_t id[2];
    uint8_t unk3;
    uint8_t num_manufacturer_blocks;
    uint16_t page_size;
    uint16_t num_pages_per_block;
    uint32_t num_blocks;
} SupportedNandChip;

static const SupportedNandChip g_supported_chips[] = {
    { { 0x98, 0xE6 }, 0x03, 0x01, 0x0200, 0x0010, 0x00000400 },
    { { 0x98, 0x73 }, 0x03, 0x01, 0x0200, 0x0020, 0x00000400 },
    { { 0x98, 0x75 }, 0x03, 0x01, 0x0200, 0x0020, 0x00000800 },
    { { 0x98, 0x76 }, 0x03, 0x01, 0x0200, 0x0020, 0x00001000 },
    { { 0x98, 0x79 }, 0x03, 0x01, 0x0200, 0x0020, 0x00002000 },
    { { 0xEC, 0xE6 }, 0x03, 0x02, 0x0200, 0x0010, 0x00000400 },
    { { 0xEC, 0x73 }, 0x03, 0x02, 0x0200, 0x0020, 0x00000400 },
    { { 0xEC, 0x75 }, 0x03, 0x02, 0x0200, 0x0020, 0x00000800 },
    { { 0xEC, 0x76 }, 0x03, 0x02, 0x0200, 0x0020, 0x00001000 },
    { { 0xEC, 0x79 }, 0x03, 0x02, 0x0200, 0x0020, 0x00002000 },
    { { 0xEC, 0x71 }, 0x03, 0x02, 0x0200, 0x0020, 0x00004000 },
    { { 0xEC, 0xDC }, 0x03, 0x02, 0x0200, 0x0020, 0x00008000 },
    { { 0xEC, 0x39 }, 0x01, 0x02, 0x0200, 0x0010, 0x00000400 },
    { { 0xEC, 0x33 }, 0x01, 0x02, 0x0200, 0x0020, 0x00000400 },
    { { 0xEC, 0x35 }, 0x01, 0x02, 0x0200, 0x0020, 0x00000800 },
    { { 0xEC, 0x36 }, 0x01, 0x02, 0x0200, 0x0020, 0x00001000 },
    { { 0xEC, 0x78 }, 0x01, 0x02, 0x0200, 0x0020, 0x00002000 },
    { { 0x20, 0x35 }, 0x01, 0x02, 0x0200, 0x0020, 0x00000800 },
    { { 0x20, 0x36 }, 0x01, 0x02, 0x0200, 0x0020, 0x00001000 },
    { { 0x20, 0x39 }, 0x01, 0x02, 0x0200, 0x0020, 0x00002000 },
    { { 0xAD, 0x35 }, 0x01, 0x02, 0x0200, 0x0020, 0x00000800 },
    { { 0xAD, 0x36 }, 0x01, 0x02, 0x0200, 0x0020, 0x00001000 },
    { { 0xAD, 0x39 }, 0x01, 0x02, 0x0200, 0x0020, 0x00002000 },
};

#define NUM_SUPPORTED_NAND_CHIPS    (sizeof(g_supported_chips)/sizeof(SupportedNandChip))

int detect_chip(void)
{
    uint8_t id[2];
    read_id(id, sizeof(id));

    for (size_t i = 0; i < NUM_SUPPORTED_NAND_CHIPS; ++i) {
        if (g_supported_chips[i].id[0] == id[0] && g_supported_chips[i].id[1] == id[1]) {
            g_emcsm_state.num_manufacturer_blocks = g_supported_chips[i].num_manufacturer_blocks;
            g_emcsm_state.page_size = g_supported_chips[i].page_size;
            g_emcsm_state.num_pages_per_block = g_supported_chips[i].num_pages_per_block;
            g_emcsm_state.num_total_blocks = g_supported_chips[i].num_blocks;

            if (model_get_identity()->model == PSP_MODEL_01G) {
                g_emcsm_state.num_manufacturer_blocks = 1;
            }

            if (g_emcsm_state.page_size != EMCSM_PAGE_SIZE || g_emcsm_state.num_pages_per_block != EMCSM_NUM_PAGES_PER_BLOCK) {
                return -2;
            }

            return 0;
        }
    }

    return -1;
}
